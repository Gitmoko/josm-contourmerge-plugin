plugins {
    id "de.undercouch.download" version "3.1.1"
}

apply plugin: "java"
apply plugin: "groovy"
apply plugin: "eclipse"

repositories {
    mavenCentral()
}

dependencies {
    compile files("contrib/josm.jar")
    testCompile group: 'junit', name: 'junit', version: '4.+' 
    testCompile localGroovy()
    testCompile files("contrib/josm.jar")
}

def currentPluginVersion(config) {
    return config.releases.collect {it.pluginVersion}.max()
}

def currentPluginMainVersion(config) {
    return config.releases.collect {it.josmVersion}.max()
}

def bestPluginVersion(config, josmVersion) {
    return config.releases
        .findAll{it.josmVersion == josmVersion}   
        .collect{it.pluginVersion}
        .max()
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.14.1'
}

jar.baseName = "contourmerge"

jar {
    manifest {
        def config = new ConfigSlurper().parse(file("releases.conf").text)
        attributes(
            "Plugin-Date": new Date().format("yyyy-MM-dd HH:mm"),
            "Plugin-Version": currentPluginVersion(config),
            "Plugin-Mainversion": currentPluginMainVersion(config),
            'Created-By': System.getProperty('java.version') + ' (' + System.getProperty('java.vendor') + ')',
            'Built-With': "gradle-${project.getGradle().getGradleVersion()}, groovy-${GroovySystem.getVersion()}",
            'Plugin-Class' : "org.openstreetmap.josm.plugins.contourmerge.ContourMergePlugin",
            "Plugin-Description": "Merges the contours of two areas",
            "Plugin-Icon" : "images/mapmode/contourmerge.png",
            "Plugin-Link" : "http://wiki.openstreetmap.org/index.php/JOSM/Plugins/ContourMerge",
            "Plugin-Canloadatruntime" : "true"
        )
        config.releases.collect{it.josmVersion}.unique().sort().each {jv -> 
            def dv = bestPluginVersion(config, jv)
            def key = "${jv}_Plugin-Url".toString()
            def value = "${dv};https://raw.github.com/Gubaer/josm-contourmerge-plugin/for-josm-${jv}/dist/contourmerge.jar".toString()
            attributes([(key):value]) 
        }
    }
}

compileJava {
  sourceCompatibility = JavaVersion.VERSION_1_8
  targetCompatibility = JavaVersion.VERSION_1_8
  options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
}

sourceSets {
    main {
        java.srcDirs = ["src"]
        output.classesDir = "build"
        resources {
            srcDir file(".")
            include "README.md"
            include "LICENSE"
            include "images/**/*"
            exclude "images/*.svg"
            exclude "images/**/*.svg"
        }
    }
    test {
        groovy.srcDirs = ["test/src"]
        output.classesDir = "test/build"
        resources {
            srcDir file("test/config")
        }
    }
}

test {
    useJUnit()
    systemProperty "josm.home", file("test/josm.home")

    afterTest { desc, result -> 
        println "Executing test ${desc.name} [${desc.className}] with result: ${result.resultType}"
    }
}

task  getJosm {
    description = "Download a JOSM jar from the JOSM website"
    doLast {
        if (! file("contrib").exists()) {
            file("contrib").mkdir()
        }
        if (!file("contrib/josm.jar").exists()) {    
            println "Downloading JOSM from <${josmDownloadUrl}> ..."    
            download {
                src josmDownloadUrl
                dest "contrib/josm.jar"
            }
        }
    }
}
compileJava.dependsOn "getJosm"

clean.doFirst {
    delete "contrib/josm.jar"
}

task deploy {
    doLast {
        def config = new ConfigSlurper().parse(file("releases.conf").text)
        def deployBranch = "deploy"
        def jar = "dist/contourmerge.jar";
        file("dist").mkdirs()
        ant.copy(todir: "dist") {
            fileset(dir : "build/libs") {
                  include(name:"contourmerge.jar")
            }
        }
        Git.ensureOnBranch(deployBranch)
        Git.add(jar)
        Git.commit(jar, "committed plugin build ${currentPluginVersion(config)}") 
        def tag = "for-josm-${currentPluginMainVersion(config)}"
        Git.tagHead(tag)
        Git.push("origin", deployBranch)
        Git.pushTags()
    }
}

class Git {
    static private def executeAndLog(cmd) {
        def proc = cmd.execute()
        proc.waitFor()
        println "Exit Value: ${proc.exitValue()}"
        println "Output: ${proc.in.text}"
        println "Error: ${proc.err.text}"
        if (proc.exitValue() != 0) {
            throw new Error("git command failed. command was <$cmd>")
        }
    }

    static def ensureOnBranch(branch) {
        def proc = "git rev-parse --abbrev-ref HEAD".execute()  
        def ret = proc.in.text.trim()
        if (ret != branch) {
            throw new Error("currently on branch '$ret', but expected branch '$branch'")
        }
    }

    static def add(file) {
        executeAndLog(["git", "add", file])
    }

    static def commit(file, message) {
        executeAndLog(["git", "commit", "-m", message, file])
    }

    static def push(remote, branch) {
        executeAndLog("git push $remote $branch")
    }

    static def tagHead(tag) {
        executeAndLog(["git", "tag", "-f", tag, "HEAD"])
    }

    static def pushTags() {
        executeAndLog("git push --tags -f") 
    }
}
